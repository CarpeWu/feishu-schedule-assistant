# 飞书消息卡片与多维表格深度集成架构研究报告：互操作性、数据转换与系统实现





## 1. 引言：企业级协作生态中的架构解耦与集成挑战



在当代企业数字化转型的浪潮中，即时通讯（IM）工具与结构化数据管理平台（Database/Low-code Platforms）的深度融合已成为提升组织效率的核心驱动力。飞书（Lark）作为这一领域的领跑者，通过其开放平台提供了两大核心组件：作为交互触点的**消息卡片（Message Card）\**与作为数据底座的\**多维表格（Bitable/Base）**。然而，在实际的企业级应用开发与业务流程自动化场景中，开发者与系统架构师频繁面临一个核心的互操作性难题：用户在聊天窗口的消息卡片中输入的数据，能否不经由中间层直接写入多维表格？以及多维表格自身的数据呈现形式与消息卡片之间存在何种语义与功能上的关联？

本报告旨在从系统架构、API协议、数据结构及中间件实现等多个维度，对上述问题进行详尽的拆解与分析。分析将明确指出，基于飞书开放平台当前的安全架构与交互模型，消息卡片无法直接（Directly）将数据“提交”至多维表格，必须依赖中间件（Middleware）或自动化流程（Automation Flow）来完成“事件-数据”的转换与持久化。同时，本报告将深入探讨多维表格内部的“卡片视图”与即时通讯中的“消息卡片”在概念模型上的本质差异。



### 1.1 核心结论概览



基于对飞书开放平台文档、API 参考及开发者社区反馈的详尽调研，本研究得出以下核心技术结论：

1. **架构隔离性（Architectural Isolation）：** 飞书消息卡片本质上是一个前端交互层（UI/Presentation Layer），其职责是收集用户输入并生成标准化事件（Event）。多维表格则是一个后端数据持久层（Data Persistence Layer），其交互依赖于严格鉴权（Authorization）与特定数据结构（Schema）的 RESTful API。两者之间不存在原生的、无需代码配置的直接数据通道。
2. **中间件的必要性（Imperative of Middleware）：** 为了连通卡片与表格，必须引入一个中间处理层。该层负责接收卡片的回调（Callback），通过“Challenge”握手验证，解析用户提交的非结构化或半结构化数据，并将其转换为多维表格所需的强类型 JSON 结构，最后调用 OpenAPI 完成写入。
3. **富文本转换的复杂性（Rich Text Transformation）：** 消息卡片使用 Markdown 语法描述富文本，而多维表格的富文本字段则要求严格的 JSON Segment 结构（如 `text_run`、`mention` 对象）。这种数据格式的不匹配要求中间件具备复杂的解析与转换算法，而非简单的字符串透传。
4. **卡片概念的二元性（Duality of "Card" Concept）：** 多维表格确实具备“卡片”形式，但这指的是**看板视图（Kanban View）\**或\**画廊视图（Gallery View）**，它们是数据的可视化呈现方式，而非用于即时通讯交互的 JSON 2.0 消息卡片。

------



## 2. 飞书消息卡片系统架构解析



要理解为何不能“直接提交”，首先必须深入剖析飞书消息卡片的运作机制。消息卡片并非一个独立的应用程序（App），而是依附于会话上下文的一种轻量级 DSL（Domain Specific Language）渲染引擎。



### 2.1 卡片 JSON 2.0 的结构化定义



随着 Card JSON 2.0 标准的引入，飞书极大地增强了卡片的布局能力与交互深度。一个标准的交互式卡片由 `header`（标题层）、`body`（内容层）和 `footer`（底部层）组成，并通过模块（Module）来承载具体的组件 1。



#### 2.1.1 表单容器（Form Container）的语义限制



在 Card JSON 2.0 中，引入了 `form` 容器组件 3，允许开发者将输入框（Input）、选择器（Select Menu）、日期选择器（Date Picker）等组件聚合在一起。这种结构在视觉上与传统的 HTML `<form>` 极其相似，但在行为逻辑上存在根本差异。

HTML 表单通常具备 `action` 属性，指向一个具体的服务器 URL，浏览器会自动将数据编码并 POST 到该地址。然而，飞书卡片的 `form` 容器并不具备指向任意 URL 的能力。其提交动作（Action）被严格封装为一种**“回传交互”（Callback Interaction）**。

| **特性**     | **HTML 表单 (Web)**               | **飞书卡片表单 (Card JSON)**         | **差异影响**                                     |
| ------------ | --------------------------------- | ------------------------------------ | ------------------------------------------------ |
| **目标地址** | 任意 URL                          | 仅限应用后台配置的“请求网址”         | 卡片无法直接指向多维表格 API 的 URL              |
| **鉴权方式** | Cookie / Session                  | 签名校验 (Signature) / Token         | 无法直接携带多维表格所需的 `tenant_access_token` |
| **数据格式** | form-data / x-www-form-urlencoded | 标准化 JSON 事件负载 (Event Payload) | 数据结构不符合多维表格 API 的 `fields` 要求      |
| **响应处理** | 页面跳转 / 刷新                   | Toast 提示 / 卡片局部更新            | 需要特定的响应结构 `{ "toast":... }`             |

从上表可见，卡片的设计初衷是与**开发者拥有的应用后端**进行通信，而非直接与飞书的其他业务模块（如多维表格）进行横向通信。这种设计确保了开放平台的安全性，防止恶意卡片随意向用户的数据资产写入数据。



### 2.2 交互事件的生命周期



当用户在卡片上点击“提交”按钮时，系统会触发 `card.action.trigger` 事件 4。这一过程涉及复杂的数据封装与传输流程：

1. **数据聚合（Aggregation）：** 客户端（PC、iOS、Android）会收集 `form` 容器内所有输入组件的值。例如，一个名为 `name="reason"` 的输入框中的文本，会被封装进 `form_value` 对象中。
2. **上下文注入（Context Injection）：** 开发者在构建卡片时预埋的 `value` 字典（如 `{"project_id": "123"}`）会被一并打包，用于维持业务上下文 6。
3. **事件投递（Dispatch）：** 飞书开放平台网关将上述数据封装为一个 HTTP POST 请求，发送至开发者在后台配置的**回调地址（Webhook URL）**。
4. **同步响应（Synchronous Response）：** 网关要求接收端在 3 秒内返回一个合法的 JSON 响应 7。这个响应不仅确认了请求的接收，还指示客户端如何处理后续 UI（例如弹出一个“提交成功”的 Toast 提示）。

**关键阻碍点：** 多维表格的 OpenAPI 接口（例如 `POST /bitable/v1/.../records`）并不具备处理这种 `card.action.trigger` 事件负载的能力。多维表格 API 期望接收的是形如 `{"fields": {"字段名": "值"}}` 的结构，而卡片发送的是包含 `operator`、`token`、`action` 等大量元数据的复杂嵌套结构 6。因此，若将卡片的回调地址直接配置为多维表格的 API 地址，调用必然失败，因为多维表格无法“理解”卡片发送的事件语言。

------



## 3. 多维表格（Bitable）的数据持久化机制



多维表格不仅是一个在线表格工具，更是一个关系型数据库。其数据写入有着严格的类型约束与格式要求，这进一步增加了从卡片直接写入的难度。



### 3.1 字段类型系统与 API 契约



在通过 API 向多维表格写入数据时，必须严格遵循每个字段类型的 JSON 结构定义 9。任何格式偏差都会导致 API 返回 `400 Bad Request` 错误。



#### 3.1.1 基础字段与复杂字段的差异



- **文本（Text）：** 最简单的类型，通常接受字符串或特定的对象数组。
- **单选（Single Select）：** 需要传递选项的名称（String）或选项 ID。如果传递了不存在的选项名称，且未开启“自动新增选项”，写入将失败。
- **人员（Person）：** 这是集成中最易出错的类型。API 要求传递用户的 `open_id`、`union_id` 或 `user_id` 10。
  - *卡片数据源：* 卡片回调事件中包含操作者的 `open_id` 6。
  - *转换需求：* 中间件必须提取这个 `open_id`，并将其封装为 `[{"id": "ou_...", "type": "user"}]` 的数组格式才能写入多维表格。卡片无法自动完成这种封装。
- **富文本（Rich Text）：** 这是最为复杂的类型，将在第 6 章详细讨论。



### 3.2 鉴权体系的隔离



多维表格 API 的调用依赖于 `tenant_access_token` 或 `user_access_token` 10。

- **获取方式：** 必须通过应用的 `app_id` 和 `app_secret` 调用鉴权接口获取。
- **生命周期：** Token 有效期通常为 2 小时，需要定时刷新。

消息卡片作为前端组件，无法安全地存储 `app_secret`，也无法在发送请求时自动申请并附加这些 Token。如果允许卡片直接携带 Token，将导致严重的安全漏洞（Token 泄露给客户端）。因此，必须由后端中间件来承担“保管密钥、申请 Token、附加 Token”的职责。

------



## 4. 集成桥梁：中间件架构与实现路径



基于上述分析，实现“卡片提交到表格”的唯一可行路径是构建一个中间件（Middleware）。这个中间件可以是开发者自建的服务（Custom Backend），也可以是低代码自动化平台（Low-Code Platform）。



### 4.1 路径 A：自建后端服务（Custom Backend）



这是最灵活但也最复杂的实现方式。通常使用 Go, Python, Node.js 等语言开发。



#### 4.1.1 核心职责一：Challenge 握手验证



当开发者在飞书后台配置请求网址时，飞书会立即发送一个 `url_verification` 类型的 POST 请求，包含一个 `challenge` 字符串。服务必须原样返回这个 `challenge` 值，才能完成配置 14。

- **请求示例：**

  JSON

  ```
  {
      "type": "url_verification",
      "challenge": "ab12cd34...",
      "token": "..."
  }
  ```

- **响应要求：**

  JSON

  ```
  {
      "challenge": "ab12cd34..."
  }
  ```

若服务无法正确识别此事件类型并返回指定 JSON，后续的卡片交互事件将永远无法送达。



#### 4.1.2 核心职责二：异步处理与快速响应



卡片交互要求 3 秒内响应 5。如果写入多维表格的操作耗时较长（例如涉及复杂的逻辑判断或重试），直接在回调线程中处理可能导致超时，引发客户端报错。

- **最佳实践：** 收到卡片请求后，立即将数据放入消息队列（Message Queue）或启动协程（Goroutine）处理，并同步返回 `{ "toast": { "content": "正在处理..." } }` 给客户端。



#### 4.1.3 核心职责三：API 代理与数据清洗



后端服务需要从 `event.action.form_value` 中提取数据，根据多维表格的字段定义进行重组。例如，将卡片中的日期字符串 `"2023-10-01"` 转换为多维表格所需的时间戳（毫秒） 10。



### 4.2 路径 B：低代码自动化平台（n8n / Feishu Flow）



对于非开发人员，利用 n8n 或飞书集成平台（AnyCross/Feishu Flow）是更优的选择。但根据研究资料，这也并非“开箱即用”，存在特定的配置陷阱。



#### 4.2.1 n8n 集成的 Webhook 挑战



在使用 n8n 的 Webhook 节点接收卡片回调时，最大的障碍是如何处理 `url_verification` 挑战。n8n 的默认 Webhook 节点通常配置为返回静态的 `200 OK`，这无法满足飞书的动态 `challenge` 返回要求 15。

- **解决方案：**
  1. **双路路由（Router）：** 在 Webhook 节点后连接一个 `Switch` 或 `If` 节点，判断 JSON Body 中的 `type` 字段。
  2. **分支处理：**
     - 若 `type == 'url_verification'`，则路由至 **"Respond to Webhook"** 节点。
     - 配置该节点以 **JSON** 模式响应，响应体设置为表达式：`{ "challenge": $json.body.challenge }` 16。
     - 若 `type == 'card.action.trigger'`，则路由至后续的数据处理流程（HTTP Request 调用多维表格 API）。
  3. **响应模式：** 必须在 Webhook 节点中设置 "Respond: Using 'Respond to Webhook' Node"，否则 n8n 会自动抢先返回默认响应，导致握手失败 17。



#### 4.2.2 飞书集成平台（Feishu Flow）



飞书官方的集成平台提供了封装好的触发器“当卡片被点击时”。这种方式屏蔽了底层的 Token 管理和 Challenge 握手，用户只需在图形化界面中拖拽“新增记录”节点即可。这是最接近用户心中“直接提交”的方案，但其本质仍是云端的中间件服务。

------



## 5. 深度技术剖析：富文本数据的算法转换



本报告中最具技术挑战性的部分在于**富文本（Rich Text）**的处理。这是导致大量集成项目失败的深水区。



### 5.1 数据结构的根本性错位



- **源头（消息卡片）：** 使用 **Markdown** 语法。
  - 用户在输入框（如果是多行文本输入框）或开发者在预设值中，可能提供如 `**加粗**`、`[链接](https://url)` 的字符串 1。
- **终点（多维表格）：** 使用 **JSON Segment（文档块）** 结构。
  - 多维表格的富文本字段并不存储 Markdown 字符串，而是存储一个由对象组成的数组（Array of Objects） 11。

错位示例：

如果开发者直接将字符串 "请查看 **项目计划**" 写入多维表格富文本字段，多维表格会将其视为一段纯文本，用户看到的就是原本的星号，而非加粗效果。



### 5.2 转换算法逻辑



要实现真正的富文本写入，中间件必须实现一个 **Markdown Parser to Bitable Schema Converter**。该算法需包含以下步骤：



#### 5.2.1 词法分析与 Token 化



将 Markdown 字符串解析为抽象语法树（AST）或 Token 流。

- 输入：`"联系 <at user_id='ou_123'>张三</at>"`
- 解析：识别出 `"联系 "` (Text) 和 `<at...>` (Mention Tag)。



#### 5.2.2 结构重组（Mapping）



将解析出的 Token 映射为 Bitable 支持的 Segment 类型。

**场景一：超链接 (Hyperlink)**

- *Card Markdown:* `[飞书开放平台](https://open.feishu.cn)`

- Bitable Segment:

  根据 API 文档 19，需要构造如下对象：

  JSON

  ```
  {
      "type": "url",
      "text": "飞书开放平台",
      "link": "https://open.feishu.cn"
  }
  ```

  或者使用带有样式的文本对象（视 API 版本而定）：

  JSON

  ```
  {
      "type": "text",
      "text": "飞书开放平台",
      "style": {
          "link": { "url": "https://open.feishu.cn" }
      }
  }
  ```

**场景二：@提及 (Mention)**

- *Card Markdown:* `<at user_id="ou_abc123">Tom</at>` 20

- *Bitable Segment:*

  JSON

  ```
  {
      "type": "mention",
      "mentionType": "User",
      "token": "ou_abc123",  // 对应 user_id
      "text": "@Tom"
  }
  ```

  *注意：* 卡片的 Markdown 中 `<at>` 标签的属性通常是 `user_id`，而多维表格 API 可能需要 `open_id` 或 `union_id`，具体取决于 Base 的配置和应用的权限范围。中间件可能需要调用 `contact/v3/users/get` 接口进行 ID 转换。

**场景三：样式文本 (Styled Text)**

- *Card Markdown:* `**紧急**`

- *Bitable Segment:*

  JSON

  ```
  {
      "type": "text",
      "text": "紧急",
      "style": {
          "bold": true
      }
  }
  ```

  中间件需要识别 `**` 标记，并将其转化为 `style` 对象中的布尔属性。



### 5.3 现成解决方案与库



对于使用 Node.js 开发中间件的用户，可以利用社区开源库如 `markdown-to-json` 或 `unified` 生态进行解析，但通常需要编写自定义的 Transformer 来适配飞书特有的 Segment 结构。在 n8n 中，这通常需要一个 "Function" (Code) 节点，编写 JavaScript 代码执行正则匹配和数组构建 16。

------



## 6. 多维表格中的“卡片”：概念辨析



针对用户查询的第二部分：“多维表格不用使用卡片形式吗？”，我们需要澄清“卡片”一词在不同语境下的语义二义性。



### 6.1 视图层面的“卡片”



多维表格确实广泛使用“卡片”作为数据的**可视化隐喻（Visualization Metaphor）**。

- 看板视图（Kanban View）：

  这是最典型的卡片形式。每一行记录被渲染为一个矩形卡片，根据某个“单选”字段（如“状态”）进行分组排列。用户可以拖拽卡片在不同“泳道”间移动，从而通过 UI 操作触发底层数据的 Update 动作 9。

  - *适用场景：* 任务管理、销售线索跟进。
  - *与消息卡片的区别：* 这是 Bitable 内部的 UI，无法发送到聊天窗口。

- 画廊视图（Gallery View）：

  这是一种以图像为主的卡片布局。它强调记录中的“附件”字段（通常是图片），将每条记录展示为一张带有封面图的大卡片。

  - *适用场景：* 设计素材库、员工花名册、商品展示。



### 6.2 交互层面的“卡片”



飞书消息卡片（Message Card）是**交互式**的，它存在于 IM 的时间流中。

- *核心特征：* 它是瞬时的（Ephemeral，随消息流滚动）、推送式的（Push-based）、轻量级的。
- *Bitable 的“卡片”：* 是持久的（Persistent）、浏览式的（Pull-based）、数据密集型的。

**结论：** 多维表格使用卡片形式来*展示*数据，但不支持直接作为*输入接口*发送到聊天中。如果用户希望在聊天中看到多维表格的记录卡片，开发者必须读取 Bitable 数据，然后按照 Card JSON 2.0 格式**重新组装**一个消息卡片发送出去。这两者是两个独立系统的不同表现形式，需要通过 API 进行数据映射。

------



## 7. 实施指南：从设计到部署



本章为技术团队提供一份标准化的实施路线图，涵盖字段映射表与错误处理策略。



### 7.1 字段映射对照表（Field Mapping Schema）



在编写中间件时，建议维护一份严格的映射配置，以确保数据类型安全。

| **卡片组件 (Card Input)** | **数据类型 (JSON)**   | **多维表格字段 (Bitable Field)** | **中间件转换逻辑 (Logic)**                                   |
| ------------------------- | --------------------- | -------------------------------- | ------------------------------------------------------------ |
| `input` (text)            | String                | **文本 (Text)**                  | 直接赋值。                                                   |
| `input` (number)          | String                | **数字 (Number)**                | `parseFloat(value)`。若 NaN 则报错。                         |
| `date_picker`             | String ("yyyy-MM-dd") | **日期 (Date)**                  | `new Date(value).getTime()`。API 需要毫秒级时间戳。          |
| `select_menu` (static)    | String (Option Value) | **单选 (Single Select)**         | 需确保 Option Value 存在于表格配置中，否则 API 报错。        |
| `select_multi`            | Array                 | **多选 (Multi Select)**          | 保持 Array 结构，或转换为 ``。                               |
| `form` (hidden value)     | String (UserID)       | **人员 (Person)**                | 提取 `open_id` -> 构造 `[{"id": open_id, "type": "user"}]`。 |
| `input` (multiline)       | String (Markdown)     | **富文本 (Rich Text)**           | 调用 Markdown Parser -> 生成 Segment Array。                 |



### 7.2 错误处理与用户反馈闭环



由于卡片提交是异步的，中间件必须妥善处理 Bitable API 可能返回的错误，并反馈给用户。

1. **API 限流（Rate Limiting）：** 多维表格 API 有频率限制（如 50 QPS 13）。
   - *策略：* 中间件应实现指数退避重试（Exponential Backoff）。若最终失败，需向用户发送一条“系统繁忙，请稍后重试”的普通文本消息。
2. **数据校验错误（Validation Error）：** 如必填字段为空、选项不存在。
   - *策略：* 解析 Bitable 返回的 `400` 错误详情，通过卡片回调的 `toast` 接口返回具体错误信息（如“‘状态’字段值无效”）。
3. **幂等性（Idempotency）：** 防止用户重复点击提交按钮。
   - *策略：* 许多卡片交互场景下，第一次点击后应通过回调更新卡片，将按钮置为“已提交”或“不可用”状态（update card），防止重复触发。



### 7.3 安全性考量



- **签名校验：** 务必在中间件中校验飞书请求头中的 `X-Lark-Request-Timestamp` 和 `X-Lark-Signature`，确保请求确实来自飞书服务器，防止伪造攻击 14。
- **权限最小化：** 为应用申请 Token 时，仅授予特定的 Base 阅读/写入权限，而非全局数据权限。

------



## 8. 总结



飞书消息卡片系统与多维表格系统虽然同属飞书生态，但分别通过“事件驱动的 UI 展现层”与“资源导向的数据持久层”两种截然不同的架构模式运作。这种解耦设计虽然增加了集成的初始复杂度，但也带来了极高的灵活性与安全性。

用户所期望的“直接提交”，在技术实现上必须转化为**“卡片 -> Webhook 事件 -> 中间件（解析/转换/鉴权） -> 多维表格 API”**这一标准链路。无论是通过自建后端还是利用 n8n 等低代码工具，核心难点均在于 Challenge 握手的正确响应、富文本格式的算法转换以及严格的字段类型映射。

同时，多维表格内部的“卡片视图”是数据管理维度的可视化工具，与即时通讯维度的“消息卡片”在功能定义上泾渭分明，但在业务流程中可以通过 API 实现数据的互通与流转，共同构建闭环的企业协作自动化方案。